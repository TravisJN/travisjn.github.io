<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>TravLearnsJS</title><description>TravLearnsJS</description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Wed, 25 Mar 2015 02:36:33 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>How to work with D3.js Transitions</title><description>&lt;p&gt;D3 is a powerful JavaScript library that allows data to be manipulated visually in the browser.  There are some incredible examples of what can be created here.  If you know how to use it, D3 can liberate your application's appearance and give your users an incredible and engaging way to interact with your product.  There are numerous tutorials online for getting started so I'm just going to delve into one particular aspect that left me scratching my head for some time until, after enough research and understanding, I was able to realize what was happening under the hood of this fantastic library.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2&gt;Transitions&lt;/h2&gt;  

&lt;p&gt;The built-in transition methods in D3 are what allow the library to be really engaging and make your applications look and feel professional without much code.  An example would be if you wanted to move a &amp;lt;div&amp;gt; with a location at { top : 0px } to a new location at { top : 20px }.  To smoothly animate the &amp;lt;div&amp;gt; down the screen with D3, you would simply type:  &lt;/p&gt;

&lt;blockquote&gt;d3.select('body').selectAll('div').transition().style('top', '20px');&lt;/blockquote&gt;  

&lt;p&gt;Easy enough, but that transition takes time.  And what if we needed to check up on it while it's transitioning?  For instance, if we were making a game and that div is a bomb that explodes as soon as it touches the player.  We would need to get inside that transition and run our "collisionCheck" function at every step.  Well D3 allows us to do just that.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2&gt;Tweening&lt;/h2&gt;  

&lt;p&gt;Tweens are the steps or animations in-between the start and end of an action.  In our example above, the start is { top : 0px } and the end is { top : 20px } so any point in which our div is shown on the screen between 1px and 19px is a tween.  (Note: D3 will refresh the screen 60 times per second so the animation doesn't just move in 1px increments).  Now let's talk about how we can run our collision detection function at each step along the transition.  It turns out that D3 has a .tween() method which allows us to run a custom function at each frame.  To use it, we would write:&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;blockquote&gt;d3.select('body')

&amp;nbsp;&amp;nbsp;.selectAll('div')

&amp;nbsp;&amp;nbsp;.transition()

&amp;nbsp;&amp;nbsp;.style('top', '20px')

&amp;nbsp;&amp;nbsp;.tween(function(time){

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var current_Y_Position = d3.select('body').selectAll('div').style('top');
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collisionDetectionFunction(yPosition);

});&lt;/blockquote&gt;

&lt;p&gt;And that's it!  The tween method allows us to call our custom function, in this case collisionDetectionFunction(). But we need to get the current 'top' value in order to check that against our player to see if they've collided, so we run a D3 selector to get our current Y position.  There's an interesting point here about how D3 acts on objects in transitions.  Each time the screen refreshes, the top value needs to be at some point in between start and end and D3's magic does the math to figure out what that top value actually needs to be at any specific frame.  If we paused the application halfway through the transition and looked at its css top value, it would be 10px.  Our css file would show { top : 10px }.  That allows us to run our D3 selector in the .tween() method and pull whatever the css value is on that frame.  Thanks D3!  There's one more aspect, let's talk about the time parameter that gets passed into our function.  time is a number between 0 and 1 where 0 is the starting frame and 1 is the ending frame of the transition so we are essentially passed how far along the transition we are as a percentage.  To clarify, exactly halfway through our example, we would have top : 10px and time = 0.5 (or 50%).&lt;/p&gt;</description><link>http://localhost:2368/how-to-work-with-d3-js-transitions/</link><guid isPermaLink="false">97c1110c-c2a7-4e6b-865b-9b60d862d7b5</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:18:12 GMT</pubDate></item><item><title>One Week of Learnin'</title><description>&lt;p&gt;Everything I've learned in the past 9 days:  &lt;/p&gt;

&lt;ul&gt;  
    &lt;li&gt;Object-Oriented Fundamentals&lt;/li&gt;
    &lt;li&gt;Recursion&lt;/li&gt;
    &lt;li&gt;Underscore.js&lt;/li&gt;
    &lt;li&gt;Scope&lt;/li&gt;
    &lt;li&gt;Closures&lt;/li&gt;
    &lt;li&gt;The Call Stack&lt;/li&gt;
    &lt;li&gt;Using Terminal with Git&lt;/li&gt;
    &lt;li&gt;jQuery&lt;/li&gt;
    &lt;li&gt;Stringify&lt;/li&gt;
    &lt;li&gt;Data Structures
&lt;ul&gt;  
    &lt;li&gt;Linked Lists, Trees, Graphs, Hash Tables, Binary Search Trees&lt;/li&gt;
&lt;/ul&gt;  

&lt;p&gt;&lt;/p&gt;&lt;/li&gt; &lt;br&gt;
    &lt;li&gt;Test Driven Development Practices&lt;/li&gt;
    &lt;li&gt;Object Constructors&lt;/li&gt;
    &lt;li&gt;Prototypal Inheritance&lt;/li&gt;
    &lt;li&gt;Inheritance Patterns&lt;/li&gt;
    &lt;li&gt;Binding "this" to the correct context&lt;/li&gt;
    &lt;li&gt;jQuery Event Delegation&lt;/li&gt;
    &lt;li&gt;and even more that I can't recall at the time...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;</description><link>http://localhost:2368/one-week-of-learnin/</link><guid isPermaLink="false">5636f9d0-2ce5-4243-b2dd-c6b4488fea7b</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:17:47 GMT</pubDate></item><item><title>jQuery Event Handler Delegation</title><description>&lt;p&gt;Today at MakerSquare we're building a dance floor application that allows the user to click a button to add dancers to a dance floor space. The app lives in the browser and the dancers are html elements that are dynamically added to the DOM at a random position. The problem I and Trace, my project partner, experienced was one I had seen before and, after a stackOverflow search, it seems that many others before us have experienced as well. The problem was as follows: We needed to be able to interact with our dancers using the mouse, and when we did, make the dancers perform an action. Because we were manipulating the appearance of html elements, we had to use jQuery to perform said action.&lt;/p&gt;

&lt;p&gt;So we set up an event listener to fire our function whenever we clicked on one of the dancers. But nothing happened. Our function wasn't firing and in fact, jQuery wasn't recognizing that any dancers were even on screen. So what's up jQuery? Are you blind or something? Silly jQuery... The fact is, when you create an event listener, jQuery takes a snapshot of the DOM at the moment of creation and if anything is added after that, it doesn't know it's there.&lt;/p&gt;

&lt;p&gt;You can work with this limitation however by pointing jQuery to your dynamically created object through an element that did exist when the event listener was created, such as the body of the html document or anything that is in the html file itself. This process is called event delegation. Let's look at some code shall we?&lt;/p&gt;

&lt;blockquote&gt;  
$('.colorDancer').on('click', function(event) {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(this).toggleClass('colorDancer');
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(this).toggleClass('colorDancerClicked');
    });
&lt;/blockquote&gt;

&lt;p&gt;This block is a jQuery event handler.  We're telling jQuery to look for any element with the class "colorDancer" and when it's clicked, remove the class "colorDancer" and the "colorDancerClicked" class.  In this example, the webpage is loaded with without any elements that have the "colorDancer" class but they can be added by the user after the page has loaded.  Because the "colorDancer" elements are created dynamically, jQuery will not be able to recognize them and the code will do nothing.  In comes event delegation:&lt;/p&gt;

&lt;blockquote&gt;  
$(&lt;strong&gt;'body'&lt;/strong&gt;).on('click', &lt;strong&gt;'.colorDancer'&lt;/strong&gt;, function(event) {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(this).toggleClass('colorDancer');
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(this).toggleClass('colorDancerClicked');
    });
&lt;/blockquote&gt;

&lt;p&gt;In order for jQuery to see our new dancers, we have to point to them through an element that existed when the event listener was created.  In this case we're using  because every page has a body and it must be in the html file therefore it is something that we know existed from the instant the page loaded.  By adding our specific target as the second argument in the .on() function, we are telling jQuery to first find body, then within body look for anything that has a "colorDancer" class.  jQuery thus finds it and toggles our classes.  Voila.&lt;/p&gt;</description><link>http://localhost:2368/jquery-event-handler-delegation/</link><guid isPermaLink="false">ff557ce1-04fb-48eb-a665-265d2f6a0017</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:17:21 GMT</pubDate></item><item><title>Hoisting in Javascript</title><description>&lt;p&gt;What will the following code output?  &lt;/p&gt;

&lt;blockquote&gt;&lt;strong&gt;var&lt;/strong&gt; someFunc = &lt;strong&gt;function&lt;/strong&gt;() {

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alert("Outside of container function");

}
&lt;br&gt;  
&lt;br&gt;  
&lt;strong&gt;var&lt;/strong&gt; container = &lt;strong&gt;function&lt;/strong&gt;() {

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;someFunc();

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;var&lt;/strong&gt; someFunc = &lt;strong&gt;function&lt;/strong&gt;() {

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alert("Inside of container function");

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}

}

container();&lt;/blockquote&gt;  

&lt;p&gt;Did you guess "Inside of container function"?  I did too.  Though, to my surprise, I was wrong.  I was wrong because of hoisting.  Hoisting is a simple concept to grasp but being ignorant of its effects can make JS give you some seemingly mysterious errors and bugs.  So here's what's happening:&lt;/p&gt;

&lt;p&gt;When your code runs, the interpreter goes through each line and looks for any variable declarations so it can assign them a block of memory.  It finds all variable declarations before executing any code and assigns the memory space before assigning those variables their values.  Even if those variables were assigned a value on the same line they were declared (they were initialized).  So we can simply imagine every variable declaration in your program is moved to the top of the code - the variables are hoisted.  Let's rewrite the above code as if it were already hoisted:  &lt;/p&gt;

&lt;blockquote&gt;&lt;strong&gt;var&lt;/strong&gt; someFunc;    //variable declaration gets hoisted to here  
&lt;strong&gt;var&lt;/strong&gt; container;    //variable declaration gets hoisted to here


&lt;del datetime="2015-03-07T16:21:32+00:00"&gt;var&lt;/del&gt; someFunc = &lt;strong&gt;function&lt;/strong&gt;() {

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alert("Outside of container function");

}


&lt;del datetime="2015-03-07T16:21:32+00:00"&gt;var&lt;/del&gt; container = &lt;strong&gt;function&lt;/strong&gt;() {  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;var&lt;/strong&gt; someFunc;   //variable declaration gets hoisted to here
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;someFunc();

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;del datetime="2015-03-07T16:21:32+00:00"&gt;var&lt;/del&gt; someFunc = &lt;strong&gt;function&lt;/strong&gt;() {

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alert("Inside of container function");

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}

}

container();&lt;/blockquote&gt;  

&lt;p&gt;Now it's clear to see why someFunc is undefined when we call container();  One more important factor I should point out is that each variable declaration gets hoisted to the top of its scope, which we see happening inside of container().  And that's hoisting!&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description><link>http://localhost:2368/hoisting-in-javascript/</link><guid isPermaLink="false">e65b28e7-c03a-40b1-974c-f301137b9153</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:16:49 GMT</pubDate></item><item><title>What's this recursion business?   Why not just use a loop?</title><description>&lt;p&gt;Recursion can be a mind bender when you're first introduced to it; a function calling itself over and over again until reaching an end case...why not just use an easy-to-understand, built-in while loop or for loop?  After all, loops are just recursive functions with an easier syntax right?  Here at MakerSquare we were asked to consider occasions when a recursive function might be more beneficial than simply using a loop.  And to be honest, I couldn't really think of one. &lt;/p&gt;

&lt;p&gt;Fortunately though, I'm lucky enough to be surrounded with extremely smart and all-around incredible people every day in class, and yesterday one such individual told me why recursion matters:  &lt;/p&gt;

&lt;p&gt;If you have a function that you need to call over and over again and that function does something that might take some time, such as retrieving data from a server, data which is used in the next call of the function, you would need recursion because you have to make sure the function completes its data retrieval before moving on to the next iteration.  If you used a simple loop in this case, it might process so quickly on your user's machine that it would be trying to run through the next iteration of the loop before the data that it needs has been retrieved, resulting in an error.  This is also called a callback function.  &lt;/p&gt;

&lt;p&gt;Boom! Clarity.  His one simple casual explanation about recursion and callback functions allowed me to see the light.  Thanks Ben!&lt;/p&gt;</description><link>http://localhost:2368/whats-this-recursion-business-why-not-just-use-a-loop/</link><guid isPermaLink="false">1d190795-a21a-4196-9d1a-ee466b49010c</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:16:03 GMT</pubDate></item><item><title>Closures in Javascript</title><description>&lt;p&gt;Closures can be a tricky bit of javascript.  Let's say you have a function that you want to call many times, and within that function is a variable that gets declared and stores a piece of data that is updated each time the function is called.  Intuitively, one would think the variable, which is declared within the function, would be recreated when the function is called and deleted when the function terminates.  But this is coding, and it ain't always intuitive.&lt;/p&gt;

&lt;p&gt;In reality, a javascript function (and everything within it) stays alive in memory until nothing else in the program points to that function.  This deep function that is saved in memory is called a closure, and closures can be your friend.  We were shown a great example of this in class by way of a function called "once".  "Once" is actually a method in UnderscoreJS that can be really useful for optimizing your code.  Essentially, if you have a  function that takes a lot of processing power that needs to be called over and over again, it can be really taxing on your users' systems and cause a frustrating slowdown.  "Once" fixes this by taking a function (your heavily taxing function) as an argument and saving its resulting value in memory so when that same function is called again, the stored result is simply returned and the function isn't run a second (or third, or fourth) time.&lt;/p&gt;

&lt;p&gt;Let's take a look at the code:  &lt;/p&gt;

&lt;blockquote&gt;  
&lt;p style="text-align:left;"&gt; _.once = function(passedFunction) {&lt;br&gt;  
&lt;/p&gt;&lt;p style="text-align:left;"&gt;    var alreadyCalled = false;     //we set a boolean here that initializes to false which&lt;br&gt;  
&lt;/p&gt;&lt;p style="text-align:left;"&gt;                                                //will tell the function if the passedFunction has been called&lt;br&gt;  
&lt;/p&gt;&lt;p style="text-align:left;"&gt;    var result;   //this variable will store the resulting value of running the function&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;    return function() {  //because we are creating a function within a function, a closure scope is created&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;        if (!alreadyCalled) {  //check if the function has been run before&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;        result = func.apply(this, arguments);  //run the function and set its value to result&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;        alreadyCalled = true;  //set alreadyCalled to true so the function is not run next time it's called&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;    }&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;    return result;  //return the value of the function&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;     };&lt;/p&gt;  
&lt;p style="text-align:left;"&gt;};&lt;/p&gt;  
&lt;/blockquote&gt;  

&lt;p style="text-align:left;"&gt;Creating a closure scope is as simple as constructing a function within a function.  Because the variables alreadyCalled and result are declared in the outer function, they are saved in memory as long as one part of the code is still pointing to it.  Therefore, when we call _.once a second time, alreadyCalled and result will retain their values from when they were called the first time even though we are calling the function again.  The reason behind this somewhat mysterious characteristic of Javascript has to do with the way JS allocates its memory when it encounters functions within functions.  As a result, we the coders reap the benefits of values being saved after the functions they're declared within terminate.  This is just one (simple) explanation of a javascript closure.&lt;/p&gt;  

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description><link>http://localhost:2368/closures-in-javascript/</link><guid isPermaLink="false">f25fa789-5192-4dbb-98c9-ee3da16782ad</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Wed, 25 Mar 2015 02:15:14 GMT</pubDate></item><item><title>Learning JavaScript</title><description>&lt;p&gt;As I begin my foray into formal Javascript education here at MakerSquare in San Francisco, I'll be sharing my experiences and things I learn along the way.  Writing out explanations of newly gained knowledge is a great way to clarify new ideas and hopefully simplify them in my own mind by trying to simplify them onto a blog post.  I hope this blog helps anyone reading it as much as it will help me.  May your (and my) coding be happy!&lt;/p&gt;</description><link>http://localhost:2368/learning-javascript/</link><guid isPermaLink="false">5a821c28-5d78-4833-adf7-470fda292689</guid><dc:creator>Travis Neufeld</dc:creator><pubDate>Tue, 24 Mar 2015 15:12:55 GMT</pubDate></item></channel></rss>